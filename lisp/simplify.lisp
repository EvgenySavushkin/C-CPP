(defun prov_posl(elem)
	(cond ((atom elem) (list elem))
	      ((eq (length elem) 1) nil)
	      ((eq (length elem) 2) (cdr elem))
	      (T (list elem))					
	)
)
(defun udal_short(L)
	(cond ((atom L) L)
	      (T  (let ((elem (car L))) (cond ((null (cdr L)) (prov_posl elem))
				              ((atom elem)(cond ((atom (cdr L)) (cdr L))
						                (T (cons elem (udal_short (cdr L))))
				                          )					
				              )
				              ((eq (length elem) 1) (udal_short (cdr L)))
		                              ((eq (length elem) 2) (cons (cadr elem) (udal_short (cdr L))))
				              (T (cons (udal_short elem) (udal_short (cdr L))))
			                )
	          )		
	      )
	)	
)



(defun not_simple(L)
	(cond ((null L) nil)
	      ((atom L) nil)
	      ((eq (car L) 0) T)
	      ((eq (length  L) 2) (cond ((eq (car L) '+) T)
                                        ((eq (car L) '-) (not_simple(cdr L)))
					((eq (car L) '*) T)
					((eq (car L) '/) T)
				   (T (or (not_simple  (car L))  (not_simple (cdr L))))
				   )

	      )
	      ((atom (car L)) (not_simple (cdr L)))
	      ;((< (length (car L)) 3) T)
	      ((not_simple (car L)) T)
	      (T (not_simple (cdr L)))
	)
)


(defun remove_elem(elem L)
    (let ((first_elem (car L))
          (tail (cdr L))
         )
         (cond ((null tail) (cond ((eq first_elem elem) nil)  
                                  ((atom first_elem) (list first_elem))
                                  (T (list (presimp first_elem))) 
                            )               
               )
               ((eq first_elem elem) (remove_elem elem tail))
               ((atom first_elem) (cons first_elem (remove_elem elem tail)))
               (T (cons (presimp first_elem) (remove_elem elem tail)))
         )
    )
)

(defun is_zero(L)
	(cond ((null L) nil)
	      ((atom (car L)) (cond ((eq (car L) 0) T)
				    (T (is_zero (cdr L)))
		              )
	      )
              (T (cond ((is_zero (car L)) T)
		       (T (is_zero (cdr L)))
		 )
	      )
	)
)



(defun presimp(L)
	(let ((znak (car L))) 
		(cond ((eq znak '+) (cond ((eq (length L) 1) nil)
					  ((eq (length L) 2) (cadr L))
			                  (T (cons znak (remove nil (remove_elem 0 (cdr L))))) 
			            )
		      )
		      ((eq znak '-) (cond ((eq (length L) 1) nil)
					  ((eq (length L) 2) (cadr L))
			                  (T (cons znak (remove nil (remove_elem 0 (cdr L))))) 
			            )
		      )
		      ((eq znak '*) (cond ((eq (length L) 1) nil)
				          ( T (cond ((is_zero (cdr L)) '0)
				                    (T  (cond ((eq (remove_elem 1 (cdr L)) nil) '1)
							      (T (cons znak (remove nil (remove_elem 1 (cdr L)))))
					                )					   
				                    )        
				              )				                        
                                           )
				    )
		      )
		      ((eq znak '/)(cond ((eq (length L) 3) (delenie L))
				         ((eq (length L) 2) (cadr L))
				         ((eq (length L) 1) nil)
					 (T '(More then three))
			           )
		      )
		      (T (cond((eq (length L) 1) (car L)) 
			      (T '(unknown mark !))
			 )
		      )
		)
	)
)

(defun delenie(L)
	(let ((delimoe (cadr L)) 
	      (delitel (caddr L)) 
		 )
		 (cond ((eq delitel 0) '(Division by zero))
		       ((eq delimoe 0) (list '/ 0))
		       ((eq delitel 1) (list '/ delimoe))
		       ((atom delimoe) (cond ((atom delitel) (cons '/ (cons delimoe (list delitel))))
					     (T  (cons '/ (cons delimoe (list (presimp delitel)))))
				       )
		       )
		       (T (cond ((atom delitel) (cons '/ (cons (presimp delimoe) (list delitel))))
			        (T (let ((simpleDelimoe (presimp delimoe))
				        (simpleDelitel (presimp delitel))
					)
					(cons '/ (cons simpleDelimoe (list simpleDelitel)))
			           )	
		                )
		          )			    		    				
		       )
		 )
	)
)

(defun simplify(L)
	(let ((temp (udal_short (presimp L)))) 
		(cond ((not_simple temp)      
		;	(print  temp)	   
		       (simplify temp))
		      (T temp)
		)
	)
)

;(print (simplify '(+)))
;(print (simplify '(*)))
;(print (simplify '(/)))
;(print (simplify '(-)))
;(print (simplify '(22)))
;(print (simplify '(22 33)))
;(print (simplify '(/ 1 (/ 2 (/ 3 0) ))))
;(print (simplify '(+ 1 2 (+) 3 4)))
;(print (simplify '(+ 1 2 (+ 22) 4 5)))
;(print (simplify '(+ 1 2 (22) 3 4)))
;(print (simplify '(+ 1 2 (+ 3 0) 0 4 (+ 0 0) 0)))
;(print (simplify '(+ 1 2 (+ 3 () 0) 0 4 (+ 0 (+ 5 (*) 0 6) 0) 0)))
;(print (simplify '(+ 1 (- 0 (* 1 1) (* 2 0 3) 4))))
;(print (simplify '(+ 1 (- 0 (* 1 0 2) 3))))
;(print (simplify '(+ 1 (- 0 (/ 2 0 3) 4))))
;(print (simplify '(+ 1 (- 0 (/ 2 3) 4))))
;(print (simplify '(+ 1 (- 0 (/ 2 (/ 3 (/ 4 1 ))) 5))))
;(print (simplify '(+ 1 (- 0 (/ 1 (/ (+ 2 0 3) 1)) 4))))
;(print (simplify '(/ 2 (/ 0 1))))
;(print (simplify '(/ 0 1)))
;(print (simplify '(+ 2 (/ 0 (/ 3 1)))))
;(print (simplify '(+ 1 0))) 
(print (simplify '(/ (- 3 2) (+ (+ 3 0) 2))))     
(print (simplify '(/ (- 3 2) (+ (- 3 0) 2))))     
(print (simplify '(+ 0 (- 1 2))))
